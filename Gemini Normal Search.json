{
  "name": "Gemini Normal Search",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "normal-search",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -480,
        80
      ],
      "id": "4f887756-1c97-4dbe-afad-0f8a63d671fc",
      "name": "Webhook",
      "webhookId": "c94fcb08-b8bc-4fb7-8496-959db98030ae"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "AIzaSyBVPj67ATK46j8z1JsEnzTX54a0wsdwzvI"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={\n  \"system_instruction\": {\n    \"parts\": [\n      {\n        \"text\": \"## Prompt: OSINT Research on Institutional Risk Links\\n\\n**Role**\\nYou are deepdiver, a Research Security Analyst conducting initial open-source intelligence (OSINT) gathering.\\n\\n---\\n\\n### <Goal>\\n\\nUsing web search capabilities, investigate potential connections (e.g., documented cooperation, funding, joint projects, shared personnel, significant mentions linking them) between **Institution A** and each item in **Risk List C** within a specified time range.\\n\\nSummarize key findings, identify any **potential intermediary organizations (B)** explicitly mentioned as linking **A** and **C**, and provide **source URLs**.\\nTreat **each item in List C individually** for investigation.\\n\\n---\\n\\n### <Information Gathering Strategy>\\n\\nFor each item in **Risk List C**:\\n\\n* Formulate search queries combining **Institution A** (`{Institution A}`, `{Location A}`) with the specific risk item from List C.\\n* If `time_range_start` and `time_range_end` are provided, incorporate this date range into your search using Google's `before:` and `after:` filters or equivalent. **CRITICAL: When time range is specified, you MUST ONLY include information from within this exact time period. Events, publications, or relationships outside this range MUST BE EXCLUDED entirely from your analysis.**\\n\\nAnalyze results from:\\n\\n* Reports, news, official sites, academic publications, or other public documents within the timeframe.\\n* Focus on **specific, verifiable connections**, not general background info.\\n\\nLook for evidence of:\\n\\n* **Direct Links**: Clear collaboration, joint funding, projects, or documented relationships.\\n* **Indirect Links**: A and C are both explicitly linked through **intermediary B** in a documented shared outcome.\\n* **Significant Mentions**: A and C are jointly discussed in a risk-related context, even without direct cooperation.\\n\\nFor **Potential B**, ensure:\\n\\n* It is explicitly cited as facilitating the A–C connection.\\n* Mere co-membership in alliances or general funding from B is **not sufficient** unless a specific A–C project via B is described and sourced.\\n\\nIf credible evidence is found:\\n\\n* Summarize the connection and assess reliability.\\n* **Avoid** irrelevant info like rankings or general institution pages unless they directly support a finding.\\n\\nIf no evidence is found:\\n\\n* Clearly note that after thorough search within the range.\\n\\n---\\n\\n### <Input>\\n\\n* **Institution A**: `{Institution A}`\\n* **Location A**: `{Location A}`\\n* **Risk List C**: `{List C}`  // Example: [\\\"Military\\\", \\\"Specific Org X\\\", \\\"Technology Y\\\"]\\n* **Time Range Start**: `{time_range_start}`  // Optional, format: \\\"YYYY-MM\\\"\\n* **Time Range End**: `{time_range_end}`  // Optional, format: \\\"YYYY-MM\\\"\\n\\n---\\n\\n### <Output Instructions>\\n\\nOutput **only** a JSON list.\\n\\nEach item in **Risk List C** must be a separate JSON object containing:\\n\\n```json\\n{\\n  \\\"risk_item\\\": \\\"string\\\",\\n  \\\"institution_A\\\": \\\"string\\\",\\n  \\\"relationship_type\\\": \\\"string\\\", // One of: \\\"Direct\\\", \\\"Indirect\\\", \\\"Significant Mention\\\", \\\"Unknown\\\", \\\"No Evidence Found\\\"\\n  \\\"finding_summary\\\": \\\"string\\\", // CRITICAL: Citations MUST match exactly with sources array positions\\n  \\\"potential_intermediary_B\\\": [\\\"string\\\"] | null, // Only if clearly described and cited.\\n  \\\"sources\\\": [\\\"string\\\"] // CRITICAL: Must contain exactly the same number of URLs as citations in finding_summary\\n}\\n```\"\n      }\n    ]\n  },\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": \"I need you to investigate potential connections between the following institution and risk items: Institution A: {{ $json['Institution '] }} Location: {{ $json.Location }} Risk List C: {{ $json['Risk List C'] }}. For each risk item, please analyze any direct or indirect connections, or significant mentions linking them with the institution.IMPORTANT INSTRUCTION:  You MUST search for each item in BOTH English AND the native language of {{ $json.Location }}. For example, if the country is \\\"China\\\", search using both English terms AND Chinese terms. If the country is \\\"Germany\\\", search using both English terms AND German terms. If the country is \\\"Worldwide\\\", search using English terms. {{ $json['Time Range'] }}.\"\n        }\n      ]\n    }\n  ],\n  \"generationConfig\": {\n    \"thinkingConfig\": {\n      \"thinkingBudget\": 12000\n    },\n    \"temperature\": 0.2,\n    \"maxOutputTokens\": 65536,\n    \"topP\": 0.95,\n    \"topK\": 10\n  },\n  \"tools\": [\n      {\n        \"codeExecution\": {}\n      },\n      {\n        \"googleSearch\": {}\n      },\n    ],\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        288,
        80
      ],
      "id": "23f33635-f31e-488c-ad34-49896aa8c0fa",
      "name": "gemini normal search"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.body.Start_Date }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "8c4c7f0b-0471-4d13-ba09-bf23e8db2a36"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4131dbfd-d5bd-4a12-91e2-eb411c3ca76f",
                    "leftValue": "={{ $json.body.Start_Date }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "notEmpty",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -256,
        80
      ],
      "id": "060459fb-c44e-4066-a6c6-b063396fe31d",
      "name": "Switch"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "227dfc30-b0fd-44c1-ab6f-7beeb7d9549c",
              "name": "Institution ",
              "value": "={{ $json.body.Target_institution }}",
              "type": "string"
            },
            {
              "id": "43a14a81-d9d2-4fba-b637-d03c32221184",
              "name": "Risk List C",
              "value": "={{ $json.body.Risk_Entity }}",
              "type": "string"
            },
            {
              "id": "455d6eb3-6011-4634-8770-a066c7621ef9",
              "name": "Location",
              "value": "={{ $json.body.Location }}",
              "type": "string"
            },
            {
              "id": "824e1212-b343-4170-8c64-57ef1dce1fe1",
              "name": "Time Range",
              "value": "",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        0,
        0
      ],
      "id": "0ec5ead6-814f-475d-9792-05af1ddb17a6",
      "name": "no date"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "227dfc30-b0fd-44c1-ab6f-7beeb7d9549c",
              "name": "Institution ",
              "value": "={{ $json.body.Target_institution }}",
              "type": "string"
            },
            {
              "id": "43a14a81-d9d2-4fba-b637-d03c32221184",
              "name": "Risk List C",
              "value": "={{ $json.body.Risk_Entity }}",
              "type": "string"
            },
            {
              "id": "455d6eb3-6011-4634-8770-a066c7621ef9",
              "name": "Location",
              "value": "={{ $json.body.Location }}",
              "type": "string"
            },
            {
              "id": "0780d100-d4d0-4b10-96e6-18fd05d4edcf",
              "name": "Time Range",
              "value": "=focusing STRICTLY on information within the specified time range {{ $json.body.Start_Date }} to {{ $json.body.End_Date }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        0,
        160
      ],
      "id": "e7e1e6c6-3ce6-4f30-a249-73df2b1467ce",
      "name": "have date"
    },
    {
      "parameters": {
        "jsCode": "// 提取字段值\nconst riskItem = $input.first().json.data[0].risk_item;\nconst institutionA = $input.first().json.data[0].institution_A;\nconst relationshipType = $input.first().json.data[0].relationship_type;\nconst findingSummary = $input.first().json.data[0].finding_summary;\nconst intermediary_B = $input.first().json.data[0].potential_intermediary_B || [];\nconst sourceUrls = $input.first().json.data[0].sources || [];\nconst renderedContent = $('gemini normal search').first().json.candidates[0].groundingMetadata.searchEntryPoint.renderedContent\nconst webSearchQueries = $('gemini normal search').first().json.candidates[0].groundingMetadata.webSearchQueries\n\n\n// 处理intermediary_B数组，转换为字符串\nlet intermediaryString = '';\nif (Array.isArray(intermediary_B) && intermediary_B.length > 0) {\n  intermediaryString = intermediary_B.join(', ');\n} else {\n  intermediaryString = 'None';\n}\n\n// 创建基本输出字符串，使用\\\\n作为换行符\nlet formattedOutput = `Risk Item: ${riskItem}\\\\nInstitution A: ${institutionA}\\\\nRelationship Type: ${relationshipType}\\\\nFinding Summary: ${findingSummary}\\\\nIntermediary B: ${intermediaryString}`;\n\n// 创建一个单独的URL字符串\nlet urlsString = '';\nif (sourceUrls.length > 0) {\n  sourceUrls.forEach((url, index) => {\n    urlsString += `${index + 1}. ${url}\\\\n`;\n  });\n  // 移除最后一个换行符\n  if (urlsString.endsWith('\\\\n')) {\n    urlsString = urlsString.slice(0, -2);\n  }\n}\n\n// 返回格式化后的结果，包含result和单独的urls数组\nreturn [{\n  json: {\n    result: formattedOutput,\n    urls: urlsString,  // 将sourceUrls作为单独的字段输出\n    // 额外添加原始数据以供参考\n    raw_data: {\n      risk_item: riskItem,\n      institution_A: institutionA,\n      relationship_type: relationshipType,\n      finding_summary: findingSummary,\n      potential_intermediary_B: intermediary_B,\n      urls: urlsString,\n      sources_count: sourceUrls.length,\n      renderedContent : renderedContent,\n      webSearchQueries : webSearchQueries\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        704,
        80
      ],
      "id": "661929ca-073e-4280-8de1-d2301f3b5765",
      "name": "清理answer和url格式2",
      "retryOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// 获取输入数据\nconst inputData = $input.all();\n\n// 从指定路径提取内容\nfunction extractFromPath(data) {\n  try {\n    // 尝试从指定路径提取\n    const candidates = data?.candidates;\n    if (candidates && Array.isArray(candidates) && candidates.length > 0) {\n      const content = candidates[0]?.content;\n      if (content && content.parts && Array.isArray(content.parts)) {\n        // 收集所有text字段的内容\n        let allTextContent = '';\n        for (let i = 0; i < content.parts.length; i++) {\n          const part = content.parts[i];\n          if (part && part.text) {\n            allTextContent += part.text;\n          }\n        }\n        \n        // 如果找到了text内容，返回合并后的文本\n        if (allTextContent) {\n          return allTextContent;\n        }\n        \n        // 如果没找到text字段，返回第一个part的JSON字符串\n        if (content.parts.length > 0) {\n          return JSON.stringify(content.parts[0]);\n        }\n      }\n    }\n    return null;\n  } catch (error) {\n    console.error('提取路径数据时出错:', error);\n    return null;\n  }\n}\n\n// 提取text字段中的JSON内容\nfunction extractJsonFromText(text) {\n  if (typeof text !== 'string') {\n    return null;\n  }\n  \n  // 查找```json 和 ``` 之间的内容\n  const jsonMatch = text.match(/```json\\s*\\n([\\s\\S]*?)\\n```/);\n  if (jsonMatch && jsonMatch[1]) {\n    return jsonMatch[1].trim();\n  }\n  \n  // 如果没找到markdown格式，尝试直接查找JSON数组或对象\n  const directJsonMatch = text.match(/(\\[[\\s\\S]*\\]|\\{[\\s\\S]*\\})/);\n  if (directJsonMatch && directJsonMatch[1]) {\n    return directJsonMatch[1].trim();\n  }\n  \n  return text; // 如果都没找到，返回原文本\n}\n\n// 清理函数\nfunction cleanJsonString(str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  \n  return str\n    // 移除或替换控制字符 (ASCII 0-31，除了 \\t \\n \\r)\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '')\n    // 清理多余的反斜杠\n    .replace(/\\\\\\\\/g, '\\\\')\n    // 修复可能的换行问题\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n')\n    // 移除零宽字符\n    .replace(/[\\u200B-\\u200D\\uFEFF]/g, '')\n    // 移除其他不可见字符\n    .replace(/[\\u2028\\u2029]/g, '');\n}\n\n// 递归清理对象中的所有字符串值\nfunction cleanObject(obj) {\n  if (typeof obj === 'string') {\n    return cleanJsonString(obj);\n  } else if (Array.isArray(obj)) {\n    return obj.map(item => cleanObject(item));\n  } else if (obj !== null && typeof obj === 'object') {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(obj)) {\n      // 清理键名\n      const cleanKey = cleanJsonString(key);\n      // 清理值\n      cleaned[cleanKey] = cleanObject(value);\n    }\n    return cleaned;\n  }\n  return obj;\n}\n\n// 验证JSON字符串的完整性\nfunction validateJsonCompleteness(jsonStr) {\n  if (!jsonStr) return false;\n  \n  // 检查基本的JSON结构\n  const trimmed = jsonStr.trim();\n  if (!trimmed.startsWith('[') && !trimmed.startsWith('{')) {\n    return false;\n  }\n  \n  // 简单的括号匹配检查\n  let braceCount = 0;\n  let bracketCount = 0;\n  let inString = false;\n  let escaped = false;\n  \n  for (let i = 0; i < trimmed.length; i++) {\n    const char = trimmed[i];\n    \n    if (escaped) {\n      escaped = false;\n      continue;\n    }\n    \n    if (char === '\\\\') {\n      escaped = true;\n      continue;\n    }\n    \n    if (char === '\"') {\n      inString = !inString;\n      continue;\n    }\n    \n    if (!inString) {\n      if (char === '{') braceCount++;\n      else if (char === '}') braceCount--;\n      else if (char === '[') bracketCount++;\n      else if (char === ']') bracketCount--;\n    }\n  }\n  \n  return braceCount === 0 && bracketCount === 0;\n}\n\n// 处理每个输入项\nconst cleanedData = inputData.map((item, itemIndex) => {\n  try {\n    // 首先从指定路径提取内容\n    let textContent = extractFromPath(item.json);\n    \n    // 如果没有找到，尝试其他可能的位置\n    if (!textContent && item.json && item.json.text) {\n      textContent = item.json.text;\n    } else if (!textContent && typeof item.json === 'string') {\n      textContent = item.json;\n    }\n    \n    if (textContent) {\n      // 从提取的文本中获取JSON内容\n      const jsonContent = extractJsonFromText(textContent);\n      \n      if (jsonContent) {\n        // 验证JSON的完整性\n        if (!validateJsonCompleteness(jsonContent)) {\n          return { \n            json: {\n              error: 'JSON内容不完整或被截断',\n              raw_content: jsonContent.substring(0, 500) + (jsonContent.length > 500 ? '...' : ''),\n              original_text: textContent.substring(0, 500) + (textContent.length > 500 ? '...' : ''),\n              debug_path: '$input.first().json.candidates[0].content.parts[x].text (合并所有text字段)',\n              suggestion: '检查是否有多个text字段需要合并'\n            }\n          };\n        }\n        \n        // 清理提取出的JSON字符串\n        const cleanedString = cleanJsonString(jsonContent);\n        \n        try {\n          // 尝试解析JSON\n          const parsed = JSON.parse(cleanedString);\n          const cleanedParsed = cleanObject(parsed);\n          \n          // 确保返回的是对象格式\n          if (Array.isArray(cleanedParsed)) {\n            // 如果解析结果是数组，将数组作为data字段返回\n            return { \n              json: {\n                data: cleanedParsed,\n                type: 'array',\n                count: cleanedParsed.length\n              }\n            };\n          } else if (typeof cleanedParsed === 'object' && cleanedParsed !== null) {\n            // 如果是对象，直接返回\n            return { json: cleanedParsed };\n          } else {\n            // 如果是基本类型，包装成对象\n            return { \n              json: {\n                value: cleanedParsed,\n                type: typeof cleanedParsed\n              }\n            };\n          }\n        } catch (parseError) {\n          console.error('JSON解析失败:', parseError);\n          // 解析失败时返回对象格式\n          return { \n            json: {\n              raw_content: cleanedString,\n              error: 'JSON解析失败: ' + parseError.message,\n              original_text: textContent.substring(0, 500) + (textContent.length > 500 ? '...' : ''),\n              debug_path: '$input.first().json.candidates[0].content.parts[x].text (合并所有text字段)',\n              json_validity_check: validateJsonCompleteness(cleanedString) ? '结构完整' : '结构不完整'\n            }\n          };\n        }\n      } else {\n        // 没有找到JSON格式时返回对象格式\n        return { \n          json: {\n            raw_content: textContent.substring(0, 500) + (textContent.length > 500 ? '...' : ''),\n            message: '未找到JSON格式内容',\n            debug_path: '$input.first().json.candidates[0].content.parts[x].text (合并所有text字段)'\n          }\n        };\n      }\n    } else {\n      // 没有找到任何内容时返回对象格式\n      return { \n        json: {\n          error: '未找到指定路径的内容',\n          debug_info: {\n            has_candidates: !!(item.json && item.json.candidates),\n            candidates_length: item.json?.candidates?.length || 0,\n            has_content: !!(item.json?.candidates?.[0]?.content),\n            parts_length: item.json?.candidates?.[0]?.content?.parts?.length || 0,\n            parts_preview: item.json?.candidates?.[0]?.content?.parts?.map((part, index) => ({\n              index: index,\n              has_text: !!part.text,\n              text_length: part.text ? part.text.length : 0,\n              keys: Object.keys(part || {})\n            })) || [],\n            full_structure: Object.keys(item.json || {})\n          },\n          debug_path: '$input.first().json.candidates[0].content.parts[x].text (合并所有text字段)',\n          item_index: itemIndex\n        }\n      };\n    }\n  } catch (error) {\n    // 处理失败时返回对象格式\n    console.error('处理数据时出错:', error);\n    return { \n      json: {\n        error: '处理失败: ' + error.message,\n        original_keys: Object.keys(item.json || {}),\n        debug_path: '$input.first().json.candidates[0].content.parts[x].text (合并所有text字段)',\n        item_index: itemIndex\n      }\n    };\n  }\n});\n\nreturn cleanedData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        528,
        80
      ],
      "id": "3292c40b-54f7-49d4-8b3e-24a523077454",
      "name": "Code1"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.2,
      "position": [
        912,
        80
      ],
      "id": "8ace50cf-48db-4c73-96d8-104c87985ff9",
      "name": "Respond to Webhook"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "gemini normal search": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "no date",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "have date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "no date": {
      "main": [
        [
          {
            "node": "gemini normal search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "have date": {
      "main": [
        [
          {
            "node": "gemini normal search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "清理answer和url格式2": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "清理answer和url格式2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "d34046b4-9bc3-4a29-b2d2-7b320996ae78",
  "meta": {
    "instanceId": "b94fff4a25c8c9acd6ea2ece249b32b40c282de9dc2e8ea313fdcf6db8d3767c"
  },
  "id": "3A6HFcrNkFWDSFYh",
  "tags": [
    {
      "createdAt": "2025-08-18T03:10:14.622Z",
      "updatedAt": "2025-08-18T03:10:14.622Z",
      "id": "24QgBw2VwapRfCs5",
      "name": "normal search"
    }
  ]
}