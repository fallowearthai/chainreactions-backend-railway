import { Request, Response } from 'express';
import { GeminiService } from '../services/GeminiService';

export interface StandardSearchRequest {
  Target_institution: string;
  Risk_Entity: string;
  Location: string;
}

export interface StandardSearchResponse {
  version: string;
  mode: 'standard';
  success: boolean;
  data: {
    entity_a: {
      name: string;
      verified_name?: string;
      description?: string;
      sectors?: string[];
    };
    entity_b: {
      name: string;
      verified_name?: string;
      description?: string;
      sectors?: string[];
    };
    relationship_analysis: {
      relationship_type: 'Direct' | 'Indirect' | 'Significant Mention' | 'No Evidence Found' | 'Unknown';
      confidence_level: 'high' | 'medium' | 'low';
      relationship_likelihood: 'high' | 'medium' | 'low';
    };
    key_findings: string[];
    search_metadata: {
      search_keywords_used: string[];
      languages_searched: string[];
      country_code: string;
    };
  };
  metadata: {
    timestamp: string;
    processing_time_ms: number;
    api_version: string;
  };
}

export class StandardSearchController {
  private geminiService: GeminiService;

  constructor() {
    this.geminiService = new GeminiService();
  }

  /**
   * Format raw Gemini response into Standard format
   */
  private formatStandardResponse(
    geminiResult: any,
    request: StandardSearchRequest,
    processingTime: number
  ): StandardSearchResponse {
    const entityA = {
      name: request.Risk_Entity,
      verified_name: geminiResult.entity_a?.original_name,
      description: geminiResult.entity_a?.description,
      sectors: geminiResult.entity_a?.sectors || []
    };

    const entityB = {
      name: request.Target_institution,
      verified_name: geminiResult.entity_b?.original_name,
      description: geminiResult.entity_b?.description,
      sectors: geminiResult.entity_b?.sectors || []
    };

    // Convert relationship likelihood to confidence
    const mapLikelihoodToConfidence = (likelihood: string): 'high' | 'medium' | 'low' => {
      switch (likelihood?.toLowerCase()) {
        case 'high': return 'high';
        case 'medium': return 'medium';
        case 'low': return 'low';
        default: return 'medium';
      }
    };

    // Extract key findings from relationship analysis
    const extractKeyFindings = (likelihood: string, entityA: any, entityB: any): string[] => {
      const findings = [];

      if (likelihood === 'high') {
        findings.push('Strong documented relationship found');
        if (entityA.description && entityB.description) {
          findings.push('Both entities verified and active');
        }
      } else if (likelihood === 'medium') {
        findings.push('Potential relationship identified');
      } else {
        findings.push('Limited connection evidence');
      }

      // Add sector-based insights
      if (entityA.sectors && entityB.sectors) {
        const commonSectors = entityA.sectors.filter((sector: string) =>
          entityB.sectors.includes(sector)
        );
        if (commonSectors.length > 0) {
          findings.push(`Shared sectors: ${commonSectors.join(', ')}`);
        }
      }

      return findings;
    };

    const relationshipLikelihood = geminiResult.search_strategy?.relationship_likelihood || 'medium';
    const keyFindings = extractKeyFindings(relationshipLikelihood, geminiResult.entity_a, geminiResult.entity_b);

    return {
      version: '1.0.0',
      mode: 'standard',
      success: true,
      data: {
        entity_a: entityA,
        entity_b: entityB,
        relationship_analysis: {
          relationship_type: this.determineRelationshipType(relationshipLikelihood),
          confidence_level: mapLikelihoodToConfidence(relationshipLikelihood),
          relationship_likelihood: relationshipLikelihood as 'high' | 'medium' | 'low'
        },
        key_findings: keyFindings,
        search_metadata: {
          search_keywords_used: geminiResult.search_strategy?.search_keywords || [],
          languages_searched: geminiResult.search_strategy?.languages || [],
          country_code: geminiResult.search_strategy?.country_code || 'unknown'
        }
      },
      metadata: {
        timestamp: new Date().toISOString(),
        processing_time_ms: processingTime,
        api_version: '1.0.0'
      }
    };
  }

  /**
   * Map Gemini likelihood to relationship type
   */
  private determineRelationshipType(likelihood: string): 'Direct' | 'Indirect' | 'Significant Mention' | 'No Evidence Found' | 'Unknown' {
    switch (likelihood?.toLowerCase()) {
      case 'high':
        return 'Direct';
      case 'medium':
        return 'Indirect';
      case 'low':
        return 'Significant Mention';
      default:
        return 'Unknown';
    }
  }

  /**
   * Handle Standard Search Request
   */
  async handleStandardSearch(req: Request, res: Response): Promise<void> {
    try {
      const searchRequest: StandardSearchRequest = {
        Target_institution: req.body.Target_institution,
        Risk_Entity: req.body.Risk_Entity,
        Location: req.body.Location
      };

      // Validate required fields
      if (!searchRequest.Target_institution || !searchRequest.Risk_Entity) {
        res.status(400).json({
          version: '1.0.0',
          mode: 'standard',
          success: false,
          error: 'Missing required fields: Target_institution, Risk_Entity'
        });
        return;
      }

      console.log('üì® Standard Search Request:', {
        entity_a: searchRequest.Risk_Entity,
        entity_b: searchRequest.Target_institution,
        location: searchRequest.Location
      });

      const startTime = Date.now();

      // Use GeminiService.verifyCompanyEntity for optimized analysis
      const geminiResult = await this.geminiService.verifyCompanyEntity(
        searchRequest.Risk_Entity,
        searchRequest.Location,
        searchRequest.Target_institution
      );

      const processingTime = Date.now() - startTime;

      // Format into Standard response
      const standardResponse = this.formatStandardResponse(
        geminiResult,
        searchRequest,
        processingTime
      );

      console.log(`‚úÖ Standard Search completed in ${processingTime}ms`);
      console.log(`üìä Relationship: ${standardResponse.data.relationship_analysis.relationship_type} (${standardResponse.data.relationship_analysis.confidence_level} confidence)`);

      res.status(200).json(standardResponse);

    } catch (error) {
      console.error('‚ùå Standard Search Error:', error);

      // Return structured error response
      const errorResponse: StandardSearchResponse = {
        version: '1.0.0',
        mode: 'standard',
        success: false,
        data: {
          entity_a: { name: req.body.Risk_Entity || 'Unknown' },
          entity_b: { name: req.body.Target_institution || 'Unknown' },
          relationship_analysis: {
            relationship_type: 'Unknown',
            confidence_level: 'low',
            relationship_likelihood: 'low'
          },
          key_findings: ['Search failed, please try again'],
          search_metadata: {
            search_keywords_used: [],
            languages_searched: [],
            country_code: 'unknown'
          }
        },
        metadata: {
          timestamp: new Date().toISOString(),
          processing_time_ms: 0,
          api_version: '1.0.0'
        }
      };

      if (!res.headersSent) {
        res.status(500).json(errorResponse);
      }
    }
  }

  /**
   * Health check for Standard Search endpoint
   */
  async healthCheck(req: Request, res: Response): Promise<void> {
    res.status(200).json({
      status: 'healthy',
      service: 'entity_relations_standard',
      version: '1.0.0',
      mode: 'standard',
      features: [
        'Fast entity verification',
        'Optimized relationship analysis',
        'Simplified response format',
        'Reduced processing time',
        'Gemini AI integration'
      ]
    });
  }

  /**
   * Get information about Standard Search service
   */
  async getInfo(req: Request, res: Response): Promise<void> {
    res.status(200).json({
      service: 'Entity Relations Standard Search',
      description: 'Optimized entity relationship analysis using Gemini AI with simplified response format',
      mode: 'standard',
      capabilities: {
        entity_verification: true,
        relationship_analysis: true,
        multi_language: true,
        fast_processing: true,
        simplified_output: true
      },
      expected_performance: {
        processing_time: '< 15 seconds',
        confidence_levels: ['high', 'medium', 'low'],
        relationship_types: ['Direct', 'Indirect', 'Significant Mention', 'Unknown']
      },
      api_endpoints: {
        search: 'POST /api/standard-search',
        health: 'GET /api/standard/health',
        info: 'GET /api/standard/info'
      },
      request_format: {
        Target_institution: 'string (required)',
        Risk_Entity: 'string (required)',
        Location: 'string (required)'
      },
      response_format: {
        version: 'string',
        mode: 'standard',
        data: {
          entity_a: 'object with verified name and description',
          entity_b: 'object with verified name and description',
          relationship_analysis: 'object with type and confidence',
          key_findings: 'array of key insights',
          search_metadata: 'object with search details'
        }
      }
    });
  }
}