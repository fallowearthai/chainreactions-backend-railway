import { ExecutionStateManager } from '../services/ExecutionStateManager';\nimport { DatasetExecutionState } from '../types/DatasetSearchTypes';\n\ndescribe('ExecutionStateManager', () => {\n  let manager: ExecutionStateManager;\n\n  beforeEach(() => {\n    manager = new ExecutionStateManager();\n  });\n\n  afterEach(() => {\n    manager.shutdown();\n  });\n\n  describe('createExecution', () => {\n    it('should create a new execution state', () => {\n      const executionId = 'test-execution-1';\n      const userId = 'user-123';\n      const institutionName = 'Test Institution';\n      const totalEntities = 100;\n\n      const execution = manager.createExecution(\n        executionId,\n        userId,\n        institutionName,\n        totalEntities\n      );\n\n      expect(execution.executionId).toBe(executionId);\n      expect(execution.userId).toBe(userId);\n      expect(execution.institutionName).toBe(institutionName);\n      expect(execution.totalEntities).toBe(totalEntities);\n      expect(execution.status).toBe('pending');\n      expect(execution.processedEntities).toBe(0);\n      expect(execution.foundRelationships).toBe(0);\n      expect(execution.cancelled).toBe(false);\n      expect(execution.results).toEqual([]);\n      expect(execution.abortController).toBeInstanceOf(AbortController);\n    });\n\n    it('should throw error for duplicate execution ID', () => {\n      const executionId = 'test-execution-1';\n      \n      manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      expect(() => {\n        manager.createExecution(executionId, 'user2', 'Institution2', 50);\n      }).toThrow('Execution test-execution-1 already exists');\n    });\n  });\n\n  describe('getExecution', () => {\n    it('should return execution state by ID', () => {\n      const executionId = 'test-execution-1';\n      const created = manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      const retrieved = manager.getExecution(executionId);\n      \n      expect(retrieved).toEqual(created);\n    });\n\n    it('should return null for non-existent execution', () => {\n      const result = manager.getExecution('non-existent');\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('updateExecution', () => {\n    it('should update execution state', () => {\n      const executionId = 'test-execution-1';\n      manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      const updated = manager.updateExecution(executionId, {\n        status: 'processing',\n        processedEntities: 50,\n        foundRelationships: 10\n      });\n      \n      expect(updated?.status).toBe('processing');\n      expect(updated?.processedEntities).toBe(50);\n      expect(updated?.foundRelationships).toBe(10);\n    });\n\n    it('should move completed execution to history', () => {\n      const executionId = 'test-execution-1';\n      manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      const updated = manager.updateExecution(executionId, {\n        status: 'completed'\n      });\n      \n      expect(updated?.status).toBe('completed');\n      expect(updated?.endTime).toBeDefined();\n      \n      // Should still be retrievable but not in active executions\n      const retrieved = manager.getExecution(executionId);\n      expect(retrieved).toBeDefined();\n      \n      const activeExecutions = manager.getActiveExecutions();\n      expect(activeExecutions.find(e => e.executionId === executionId)).toBeUndefined();\n    });\n\n    it('should return null for non-existent execution', () => {\n      const result = manager.updateExecution('non-existent', { status: 'processing' });\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('cancelExecution', () => {\n    it('should cancel active execution', () => {\n      const executionId = 'test-execution-1';\n      const execution = manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      const cancelled = manager.cancelExecution(executionId);\n      \n      expect(cancelled).toBe(true);\n      expect(execution.cancelled).toBe(true);\n      expect(execution.status).toBe('cancelled');\n      expect(execution.abortController.signal.aborted).toBe(true);\n      expect(execution.endTime).toBeDefined();\n    });\n\n    it('should return false for non-existent execution', () => {\n      const cancelled = manager.cancelExecution('non-existent');\n      expect(cancelled).toBe(false);\n    });\n  });\n\n  describe('getActiveExecutions', () => {\n    it('should return only active executions', () => {\n      // Create multiple executions\n      manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      manager.createExecution('exec2', 'user2', 'Institution2', 50);\n      manager.createExecution('exec3', 'user3', 'Institution3', 75);\n      \n      // Complete one execution\n      manager.updateExecution('exec2', { status: 'completed' });\n      \n      const activeExecutions = manager.getActiveExecutions();\n      \n      expect(activeExecutions).toHaveLength(2);\n      expect(activeExecutions.map(e => e.executionId)).toEqual(\n        expect.arrayContaining(['exec1', 'exec3'])\n      );\n      expect(activeExecutions.map(e => e.executionId)).not.toContain('exec2');\n    });\n  });\n\n  describe('getUserExecutions', () => {\n    it('should return executions for specific user', () => {\n      manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      manager.createExecution('exec2', 'user2', 'Institution2', 50);\n      manager.createExecution('exec3', 'user1', 'Institution3', 75);\n      \n      const userExecutions = manager.getUserExecutions('user1');\n      \n      expect(userExecutions).toHaveLength(2);\n      expect(userExecutions.map(e => e.executionId)).toEqual(\n        expect.arrayContaining(['exec1', 'exec3'])\n      );\n    });\n\n    it('should include history when requested', () => {\n      manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      manager.createExecution('exec2', 'user1', 'Institution2', 50);\n      \n      // Complete one execution (moves to history)\n      manager.updateExecution('exec2', { status: 'completed' });\n      \n      const userExecutionsActiveOnly = manager.getUserExecutions('user1', false);\n      expect(userExecutionsActiveOnly).toHaveLength(1);\n      \n      const userExecutionsWithHistory = manager.getUserExecutions('user1', true);\n      expect(userExecutionsWithHistory).toHaveLength(2);\n    });\n  });\n\n  describe('getMetrics', () => {\n    it('should return correct execution metrics', () => {\n      // Create executions with different statuses\n      manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      manager.createExecution('exec2', 'user2', 'Institution2', 50);\n      manager.createExecution('exec3', 'user3', 'Institution3', 75);\n      \n      manager.updateExecution('exec1', { status: 'processing' });\n      manager.updateExecution('exec2', { status: 'completed' });\n      manager.cancelExecution('exec3');\n      \n      const metrics = manager.getMetrics();\n      \n      expect(metrics.totalActiveExecutions).toBe(1); // Only processing one\n      expect(metrics.executionsByStatus.pending).toBe(0);\n      expect(metrics.executionsByStatus.processing).toBe(1);\n      expect(metrics.executionsByStatus.completed).toBe(1);\n      expect(metrics.executionsByStatus.cancelled).toBe(1);\n      expect(metrics.executionsByStatus.error).toBe(0);\n      expect(metrics.totalExecutionsProcessed).toBe(3);\n    });\n\n    it('should calculate average execution time for completed executions', async () => {\n      const exec1 = manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      \n      // Simulate some processing time\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      manager.updateExecution('exec1', { status: 'completed' });\n      \n      const metrics = manager.getMetrics();\n      \n      expect(metrics.averageExecutionTime).toBeGreaterThan(0);\n    });\n  });\n\n  describe('getMemoryStats', () => {\n    it('should return memory usage statistics', () => {\n      manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      manager.createExecution('exec2', 'user2', 'Institution2', 50);\n      \n      // Complete one (moves to history)\n      manager.updateExecution('exec2', { status: 'completed' });\n      \n      const memoryStats = manager.getMemoryStats();\n      \n      expect(memoryStats.activeExecutions).toBe(1);\n      expect(memoryStats.historyExecutions).toBe(1);\n      expect(memoryStats.totalMemoryItems).toBe(2);\n      expect(memoryStats.estimatedMemoryUsage).toContain('MB');\n    });\n  });\n\n  describe('forceCleanup', () => {\n    it('should force remove execution from memory', () => {\n      const executionId = 'test-execution-1';\n      manager.createExecution(executionId, 'user1', 'Institution1', 100);\n      \n      const cleaned = manager.forceCleanup(executionId);\n      \n      expect(cleaned).toBe(true);\n      expect(manager.getExecution(executionId)).toBeNull();\n    });\n\n    it('should return false for non-existent execution', () => {\n      const cleaned = manager.forceCleanup('non-existent');\n      expect(cleaned).toBe(false);\n    });\n  });\n\n  describe('shutdown', () => {\n    it('should cancel all active executions and clear memory', () => {\n      const exec1 = manager.createExecution('exec1', 'user1', 'Institution1', 100);\n      const exec2 = manager.createExecution('exec2', 'user2', 'Institution2', 50);\n      \n      manager.shutdown();\n      \n      expect(exec1.cancelled).toBe(true);\n      expect(exec2.cancelled).toBe(true);\n      expect(exec1.abortController.signal.aborted).toBe(true);\n      expect(exec2.abortController.signal.aborted).toBe(true);\n      \n      expect(manager.getActiveExecutions()).toHaveLength(0);\n      expect(manager.getMemoryStats().totalMemoryItems).toBe(0);\n    });\n  });\n});